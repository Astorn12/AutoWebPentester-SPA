import { PentestWithDetailsAgent } from './../_model/pentestWithDetailsAgent';
import { Website } from './../_model/website';
import { PentestOutcomeAgent } from './../_model/pentestOutcomeAgent';
import { stringify } from 'querystring';
import { PentestToCarryOn } from './../_model/pentestToCarryOn';

import { PentestService } from './../_services/pentest.service';
import { Component, OnInit, ViewChild } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { Tag } from '../_model/tag';
import { TagKind } from '../_model/TagKind';
import { ActivatedRoute, Router } from '@angular/router';
import { MatRadioGroup } from '@angular/material/radio';
import { Pentest } from '../_model/pentest';
import { FormGroup, ValidatorFn, AbstractControl, FormBuilder } from '@angular/forms';
import { PentestWithDetails } from '../_model/pentestWithDetails';
import { MatHorizontalStepper, MatStep } from '@angular/material/stepper';
import { Input } from '@angular/compiler/src/core';
import { PentestOutcome } from '../_model/pentestOutcome';
import { Resource } from '../_model/resource';



@Component({
  selector: 'app-attacks',
  templateUrl: './attacks.component.html',
  styleUrls: ['./attacks.component.css']
})
export class AttacksComponent implements OnInit {


  pentestSortKinds: TagKind[];
  favoriteSeason: string;

  choosenTag: TagKind;
  choosenPentest: PentestWithDetails;
  @ViewChild('radioGroup') radioGroup: MatRadioGroup;
  @ViewChild('stepper') stepper: MatHorizontalStepper;

  isLinear = true;
  //firstFormGroup: FormGroup;
  //secondFormGroup: FormGroup;

  waitingForPentestOutput: boolean;

  websiteToPentest: string;

  choosenPentestOutcome: PentestOutcome;

  website: Website;
  resultCompleteness: boolean=false;

  submittedFormData;
  jsonFormOptions = {
    loadExternalAssets: false,
  };

  requirementsCompleted: boolean = false;
  inputCompleted: boolean = false;
  outcomeCompleted: boolean=false;

  pentestToProvideResources: Pentest[];

  requiredResourdesLoading: boolean=false;
  inputCompleteness: boolean=false;
  requirementCompleteness: boolean=false;

  constructor(private _service: PentestService, private route: ActivatedRoute,private _formBuilder: FormBuilder,private router: Router) {

 
  }

  ngOnInit() {
    this.route.data.subscribe(data => {
      this.pentestSortKinds= data['options'];
    });
    
    this.choosenTag = this.pentestSortKinds[0];
    
    this.websiteToPentest = this.route.snapshot.params['websitetopentest'];
    if (this.websiteToPentest != "") this.websiteToPentest = "karola.com";
    this._service.getWebsite(this.websiteToPentest).subscribe((result: Website) => {
      this.website = result;


      let alreadyChoosenPentestId=this.route.snapshot.params['choosenpentestid'];

    if(alreadyChoosenPentestId){
      this._service.getPentestDetails(this.website.id,alreadyChoosenPentestId).subscribe((result: PentestWithDetailsAgent)=>{
        this.choosenPentest= new PentestWithDetails(result.id,result.name,JSON.parse(result.inputs),result.requirements);
      })
    }

    })


  }

  fillWithPentests() {

    for(let i= 0; i<<this.pentestSortKinds.length;i++){
      for(let j=0;j<this.pentestSortKinds[i].tags.length;j++){
        this.pentestSortKinds[j].tags[j].pentests=new Array<Pentest>();
      }
    };

    //   this.pentestSortKinds.forEach(element => {
    //   element.tags.forEach(tag => {
    //     tag.pentests = new Array<Pentest>();
       
    //   }
    //   )
    // });
  }

  loadPentestsProvidedResource(resource: Resource) {
    
     this._service.getPentestsProvideredrResource(resource.id).subscribe((result: Pentest[])=>{
        this.pentestToProvideResources=result;
     });
  }

  next(){
    this.stepper.selected.completed=true;
      this.stepper.next();
      if(!this.choosenPentest.inputs){
      this.startPentest(null);
    }
  }

  

  radioChange(tagKind: TagKind) {
    this.choosenTag = tagKind;
  }

  setChoosenPentest(pentest: PentestWithDetails) {
    this.choosenPentest = pentest;

  //  if(this.stepper){
      //if(this.stepper.selectedIndex)   this.stepper.selectedIndex=0
      
    if(this.stepper) this.stepper.reset();

  //}
    this.resultCompleteness=false;
    this.choosenPentestOutcome=null;
    this.inputCompleteness=false;
    this.requirementCompleteness=false;

    
    
  }


  startPentest(input: Input) {
    this.stepper.selected.completed=true;
    this.stepper.next();
    this.waitingForPentestOutput = true;

    let pentestToCarryOn: PentestToCarryOn = new PentestToCarryOn(this.choosenPentest.id, this.choosenPentest.name, JSON.stringify(input));
    this.resultCompleteness=false;
    this._service.carryOnPentest(pentestToCarryOn).subscribe((result: PentestOutcomeAgent) => {
      this.waitingForPentestOutput = false;

      this.choosenPentestOutcome = new PentestOutcome(result.id, JSON.parse(result.outcome));
      this.resultCompleteness=true;
    })


  }

  areRequirementsFulfilled(resources: Resource[]) {
    
    if (resources && resources.length>0) {

      for(let i=0;i<resources.length;i++){
        if(!resources[i].isFound) return false;
      }
    
    }
    return true;
  }

  openNewPentest(pentest: Pentest){
    
    let baseUrl = window.location.href.replace(this.router.url, '');

    window.open(baseUrl + "/attacks/"+this.website.url+"/"+pentest.id, '_blank');

    //window.open(,"_blank");
  }


  onSubmit(data: any) {
    this.submittedFormData = data;
  }

  showFormSchemaFn($event) {
    console.log($event);
  }

  showFormLayoutFn($event) {
    console.log($event);
  }
  
  stepClick(ev) {
    console.log(ev);
    
  }

  realoadRequiredResources(){
    this.requiredResourdesLoading=true;
    this._service.getResources(this.choosenPentest.id,this.website.id).subscribe((result: Resource[] )=>{
      this.choosenPentest.resources=result;
      this.requiredResourdesLoading=false;
    })
  }

}
export function requirementsFulfilled(resources: Resource[]): ValidatorFn {

  return (control: AbstractControl): { [key: string]: boolean } | null => {
    if (resources.every(element=>{!element.isFound})) {
      return { 'resources not fulfilled': true };
    }
    return null;
};
};

