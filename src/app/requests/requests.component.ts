import { HeaderPossibleValue } from '../_model/headerPossibleValue';
import { HttpVersion } from './../_model/httpVersion';
import { HttpRequestsService } from './../_services/httpRequests.service';
import { Component, OnInit } from '@angular/core';
import { FormControl } from '@angular/forms';
import { Observable } from 'rxjs';
import { map,startWith } from 'rxjs/operators';
import { Method } from '../_model/method';
import { ActivatedRoute } from '@angular/router';
import { Header } from '../_model/header';
import { ResponseI } from '../_model/responseI';


@Component({
  selector: 'app-requests',
  templateUrl: './requests.component.html',
  styleUrls: ['./requests.component.css','./request.component.scss']
})
export class RequestsComponent implements OnInit {
  chosenHeaders :Header[];
  allHeaders : Header[];
  options : Method[];
  httpVersion= ["HTTP/1"];
  
  myControl = new FormControl();
  myControl1 = new FormControl();
  versionControl = new FormControl();
  filteredOptions: Observable<Method[]>;

  response : ResponseI;

  private _editor: any;
  editorLanguage: string = 'sql';

  editorVal: string= `
  GET /start HTTP/1.1

  Host: training.com
  
  `;
 

  
  constructor(private _service: HttpRequestsService,private route:ActivatedRoute) {
    this.chosenHeaders= new Array();
    
    this.addHeader();
    
   }

  ngOnInit() {


    this.route.data.subscribe(data=>{
      this.options=data['options'];
    });
    this.loadHeaders();
    

 
    this.filteredOptions = this.myControl.valueChanges
    .pipe(
      startWith<string | Method>(''),
      map(value => typeof value === 'string' ? value : value.name),
      map(name => name ? this._filter(name) : this.options.slice())
    );
}

 
loadHttpMethods(){
  this._service.getHttpMethods().subscribe((result:any[])=>{
    this.options=result});
      }
loadHeaders(){
  this._service.getHeaders().subscribe((result:Header[])=>{
    this.allHeaders=result;
  });
}

addValue(header:Header){
 header.choosenValues.push(new HeaderPossibleValue());
}

removeValue(header: Header,value:HeaderPossibleValue){
  const index = header.choosenValues.indexOf(value, 0);
if (index > -1) {
  header.choosenValues.splice(index,1);
}
 
}

addHeader(){
  var newHeader= new Header();
  newHeader.choosenValues.push(new HeaderPossibleValue());
  this.chosenHeaders.push(newHeader);
}
removeHeader(header: Header){
  const index = this.chosenHeaders.indexOf(header, 0);
  if (index > -1) {
    this.chosenHeaders.splice(index,1);
  }
}

mapHeader(newHeader :Header, shematHeader: Header ){
    newHeader.possibleValues=shematHeader.possibleValues;
}

nullPossibleValues(header: Header){
header.possibleValues=new Array<HeaderPossibleValue>();
}

makeRequest(){
  this._service.makeRequest().subscribe((result:ResponseI)=>{
    this.response=result;
 // this.response.statusCode="200";
 
})
}



  displayFn(options: Method[]): (name: string) => string | null {
    return (id: string) => { 
      const correspondingOption = Array.isArray(options) ? options.find(option => option.name === name) : null;
      return correspondingOption ? correspondingOption.name : '';
    }
  }

  private _filter(name: string): Method[] {
    const filterValue = name.toLowerCase();

    return this.options.filter(option => option.name.toLowerCase().indexOf(filterValue) === 0);
  }


  editorInitialized(editorInstance: any): void {
    this._editor = editorInstance;
  }
 
  

}
